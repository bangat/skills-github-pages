<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Cache-Control" content="no-store" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>구매현황 엑셀 업로더</title>
  <style>
    :root{
      color-scheme: light; --bg:#f4f7fb; --card:#fff; --text:#0f172a; --muted:#5b677a; --border:#e6eaf2; --accent:#2563eb;
      --r:14px; --shadow:0 10px 30px rgba(15,23,42,.10);
    }
    *{box-sizing:border-box}
    html,body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Apple SD Gothic Neo,sans-serif}
    .wrap{max-width:980px;margin:16px auto;padding:0 14px}
    .card{background:var(--card);border:1px solid var(--border);border-radius:var(--r);box-shadow:var(--shadow);padding:24px}
    h1{margin:0 0 8px;font-size:20px}
    label{display:block;margin:12px 0 6px;color:#334155;font-weight:800;font-size:14px;}
    .btn{
        display:flex; align-items:center; justify-content:center;
        width:100%; height:48px; margin-top:16px;
        padding:10px 16px;border:none;border-radius:12px;
        background:linear-gradient(180deg,#4f83ff,#2563eb);
        color:#fff;font-weight:900;font-size:16px;cursor:pointer;
    }
    .btn:disabled{background: #a5b4fc; cursor:not-allowed}
    .log{font-family:ui-monospace,Consolas,monospace;background:#0b1220;color:#bfe0ff;padding:12px;border-radius:10px;white-space:pre-wrap;min-height:160px;font-size:12px; line-height: 1.6;}
    table{border-collapse:collapse;width:100%;margin-top:8px}
    th,td{border:1px solid var(--border);padding:6px 8px;font-size:12px; text-align:center;}
    th{background:#f1f5fb}
    .ok{color:#16a34a} .warn{color:#f59e0b} .err{color:#ef4444}
    #preview {
        overflow-x: auto; -webkit-overflow-scrolling: touch;
        border: 1px solid var(--border); border-radius: 8px; margin-top: 8px;
    }
    #preview table { margin-top: 0; border: none; width: auto; min-width: 100%; }
    #file-upload-area {
        margin-top: 16px;
        border: 2px dashed var(--border);
        border-radius: 12px;
        padding: 24px;
        text-align: center;
        cursor: pointer;
        transition: background-color 0.2s, border-color 0.2s;
    }
    #file-upload-area:hover, #file-upload-area.dragover {
        background-color: #f8fafc;
        border-color: var(--accent);
    }
    #file-upload-area .upload-icon {
        width: 40px; height: 40px;
        color: var(--accent);
        margin: 0 auto 12px;
    }
    #file-upload-area .upload-text {
        font-weight: 600;
        color: var(--muted);
    }
    #file-upload-area .file-name {
        margin-top: 8px;
        font-weight: 800;
        color: var(--accent);
        font-size: 14px;
    }
    input[type="file"] { display: none; }
    @media (max-width: 640px) {
        .wrap { margin: 0; padding: 0; }
        .card { border-radius: 0; border-left:0; border-right:0; padding: 18px; }
        h1 { font-size: 18px; }
        p { font-size: 14px; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>구매현황 엑셀 업로더</h1>
    <p style="margin:0 0 10px;color:#475569">요약 엑셀(.xlsx)을 선택하면 서버 데이터를 업데이트합니다.</p>

    <div style="display:none;">
      <input id="dbURL" type="text" value="https://hallymlinen-default-rtdb.firebaseio.com">
      <input id="basePath" type="text" value="/purchase_status">
    </div>

    <input type="file" id="filePick" accept=".xlsx,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet">
    <label for="filePick" id="file-upload-area">
        <div class="upload-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
        </div>
        <div class="upload-text">파일을 선택하거나 여기에 드래그하세요</div>
        <div class="file-name" id="fileName"></div>
    </label>

    <button id="runBtn" class="btn" disabled>업로드 시작</button>

    <label style="margin-top:16px">진행 로그</label>
    <div id="log" class="log"></div>

    <div id="sheetArea" style="margin-top:16px;display:none">
      <label>시트 미리보기</label>
      <select id="sheetSel"></select>
      <div id="preview"></div>
    </div>
  </div>
</div>

<script>
/* ------------ Basic Helpers ------------ */
const $ = s => document.querySelector(s);
const logEl = $("#log");
const log = (m, cls = '') => {
  console[cls === 'err' ? 'error' : (cls === 'warn' ? 'warn' : 'log')](m);
  logEl.innerHTML += (cls ? `<span class="${cls}">` : '') + (typeof m === 'string' ? m : JSON.stringify(m)) + (cls ? '</span>' : '') + "\n";
  logEl.scrollTop = logEl.scrollHeight;
};
const updateBtn = () => $("#runBtn").disabled = !($("#filePick").files.length > 0);

/* ------------ File Parsing & UI Handling ------------ */
let workbook = null, sheetNames = [];
const fileInput = $("#filePick");
const uploadArea = $("#file-upload-area");
const fileNameEl = $("#fileName");

const handleFileSelect = (file) => {
    if (!file) return;
    fileNameEl.textContent = file.name;

    $("#preview").innerHTML = ""; 
    $("#sheetArea").style.display = "none"; 
    workbook = null; 
    sheetNames = [];
    logEl.textContent = "";

    try {
        const reader = new FileReader();
        reader.onload = (e) => {
            const buf = e.target.result;
            workbook = XLSX.read(buf, { type: 'array', cellDates: true });
            sheetNames = workbook.SheetNames || [];
            if (!sheetNames.length) { log("시트를 찾을 수 없습니다.", 'err'); return; }

            const sel = $("#sheetSel");
            sel.innerHTML = sheetNames.map(n => `<option value="${n}">${n}</option>`).join("");
            $("#sheetArea").style.display = "block";
            renderPreview(sel.value);
            log(`엑셀 로드 성공: 시트 ${sheetNames.length}개`);
        };
        reader.readAsArrayBuffer(file);
    } catch (err) {
        log(`엑셀 파싱 실패: ${err}`, 'err');
    } finally {
        updateBtn();
    }
}

fileInput.addEventListener('change', (e) => handleFileSelect(e.target.files[0]));
$("#sheetSel").addEventListener('change', () => renderPreview($("#sheetSel").value));

uploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadArea.classList.add('dragover');
});
uploadArea.addEventListener('dragleave', () => {
    uploadArea.classList.remove('dragover');
});
uploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadArea.classList.remove('dragover');
    const files = e.dataTransfer.files;
    if (files.length > 0) {
        fileInput.files = files;
        handleFileSelect(files[0]);
    }
});

function renderPreview(name) {
  if (!workbook) return;
  const ws = workbook.Sheets[name];
  const rows2d = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" });
  let html = `<table>`;
  rows2d.slice(0, 20).forEach((row, i) => { html += `<tr>${row.map(cell => `<${i===0?'th':'td'}>${String(cell)}</${i===0?'th':'td'}>`).join("")}</tr>`; });
  html += `</table>`;
  $("#preview").innerHTML = html;
}

/* ------------ Schema Mapping & Data Processing ------------ */
function mapLabelToApp(label) {
    const s = String(label || '').trim();
    const sheetItems = ["대시트","반시트","베갯잇","수건","중환의","얼음포","억제대","고관절XL","고관절L","고관절M"];
    if (sheetItems.includes(s)) return { item: s, topBottom: '' };
    const match = s.match(/^(일반|정형)(상의|하의)의?(4XL|3XL|2XL|XL|L|M|S)$/);
    if (match) {
        const [_, kind, tb, size] = match;
        const prefix = kind === '일반' ? '일반환의' : '정형환의';
        return { item: `${prefix}${size}`, topBottom: tb };
    }
    return { item: s, topBottom: '' };
}

function buildRecordsFromSheet(ws, sheetName, year) {
    if (!ws || !ws['!ref']) return { records: [], months: new Set(), items: new Set(), year: year };

    const records = [], monthsInSheet = new Set(), itemsInSheet = new Set();
    const isMonthlyOrders = /발주월별/.test(sheetName);
    const isDailyReceipts = /입고_날짜별/.test(sheetName);

    // 엑셀 시트의 전체 범위를 가져옵니다 (예: A1:Z50)
    const range = XLSX.utils.decode_range(ws['!ref']);
    const headerRow = 0; 
    const dataStartRow = 1;

    // 1. 헤더 분석
    const headerMap = {};
    for (let C = range.s.c + 1; C <= range.e.c; ++C) { // B열부터 마지막 열까지
        const cellAddress = XLSX.utils.encode_cell({ r: headerRow, c: C });
        const cell = ws[cellAddress];
        if (!cell || !cell.v) continue;

        let recordData = null;

        if (isMonthlyOrders) {
            const match = String(cell.w || cell.v).trim().match(/^(\d{2})년\s*(\d{1,2})월$/);
            if (match) {
                year = `20${match[1]}`;
                const m = String(match[2]).padStart(2, '0');
                recordData = { section: 'orders', monthKey: `${year}-${m}`, ts: new Date(`${year}-${m}-01`).getTime() };
            }
        } else if (isDailyReceipts) {
            let dateInfo = null;
            // cell.v가 Date 객체인지 직접 확인합니다.
            if (cell.v instanceof Date) {
                const d = cell.v;
                dateInfo = { y: d.getFullYear(), m: d.getMonth() + 1, d: d.getDate() };
            } else { // Date 객체가 아니면 '9월 19일' 같은 텍스트인지 확인합니다.
                const match = String(cell.w || cell.v).trim().match(/^(\d{1,2})월\s*(\d{1,2})일$/);
                if (match && year) {
                    dateInfo = { y: year, m: match[1], d: match[2] };
                }
            }
            if (dateInfo) {
                const yyyy = String(dateInfo.y);
                const mm = String(dateInfo.m).padStart(2, '0');
                recordData = { section: 'receipts', monthKey: `${yyyy}-${mm}`, day: Number(dateInfo.d) };
            }
        }
        if (recordData) headerMap[C] = recordData;
    }

    // 2. 데이터 행 분석
    for (let R = dataStartRow; R <= range.e.r; ++R) {
        const labelCellAddress = XLSX.utils.encode_cell({ r: R, c: range.s.c });
        const labelCell = ws[labelCellAddress];
        const label = labelCell ? String(labelCell.w || labelCell.v).trim() : '';
        if (!label) continue;
        
        const { item, topBottom } = mapLabelToApp(label);
        itemsInSheet.add(item);

        for (const colIndex in headerMap) {
            const cellAddress = XLSX.utils.encode_cell({ r: R, c: Number(colIndex) });
            const cell = ws[cellAddress];
            const qty = cell ? Number(cell.v) : 0;
            if (!qty || !Number.isFinite(qty)) continue;

            const headerData = headerMap[colIndex];
            monthsInSheet.add(headerData.monthKey);
            records.push({ item, topBottom, qty, ...headerData });
        }
    }
    
    return { records, months: monthsInSheet, items: itemsInSheet, year };
}
/* ------------ Uploader (REST API) ------------ */
// [수정됨] 이 함수가 변경되었습니다.
async function deleteExistingData(section, monthsToDelete, itemsToDelete, basePath) {
    if (monthsToDelete.size === 0 || itemsToDelete.size === 0) return;
    const rootBase = $("#dbURL").value.replace(/\/$/, '');
    const updates = {};
    const sectionLabel = section === 'orders' ? '발주' : '입고';

    log(`[데이터 삭제] 엑셀에 포함된 ${sectionLabel} 데이터(${monthsToDelete.size}개월치)를 삭제합니다...`, 'warn');

    for (const item of itemsToDelete) {
        for (const month of monthsToDelete) {
            updates[`${basePath}/${item}/${section}/${month}`] = null;
        }
    }

    const res = await fetch(`${rootBase}/.json`, { method: 'PATCH', body: JSON.stringify(updates) });
    
    // 이 부분이 수정되었습니다.
    if (!res.ok) {
        // 오류를 발생시키는 대신, 경고 로그를 남기고 함수를 종료합니다.
        log(`> 기존 ${sectionLabel} 데이터 삭제에 실패했거나 삭제할 데이터가 없습니다. (오류: ${res.statusText}) 업로드를 계속 진행합니다.`, 'warn');
    } else {
        log(`> 기존 ${sectionLabel} 데이터 삭제 완료.`, 'ok');
    }
}

async function uploadSheetData(records, basePath) {
  if (!records || records.length === 0) return;
  const rootBase = $("#dbURL").value.replace(/\/$/, '');
  const updates = {};
  for (const r of records) {
    const path = `${basePath}/${r.item}/${r.section}/${r.monthKey}`;
    const key = `${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
    updates[`${path}/${key}`] = r.section === 'orders' 
      ? { qty: r.qty, topBottom: r.topBottom, ts: r.ts }
      : { qty: r.qty, topBottom: r.topBottom, day: r.day };
  }
  const res = await fetch(`${rootBase}/.json`, { method: 'PATCH', body: JSON.stringify(updates) });
  if (!res.ok) throw new Error(`업로드 실패 ${res.status}: ${await res.text()}`);
  log(`> ${records.length}개 레코드 업로드 완료.`);
}

/* ------------ Run Handler (Main Logic) ------------ */
/* ------------ Run Handler (Main Logic) ------------ */
$("#runBtn").addEventListener('click', async () => {
    if (!workbook) { log("엑셀을 먼저 선택하세요.", 'err'); return; }

    const basePath = $("#basePath").value.trim();
    $("#runBtn").disabled = true;
    logEl.textContent = "";
    let year = null; // 연도를 null로 초기화

    try {
        log('[시작] 데이터 업로드를 시작합니다.');
        const orderSheetName = sheetNames.find(name => /발주월별/.test(name));
        const receiptSheetName = sheetNames.find(name => /입고_날짜별/.test(name));

        // 1. 발주 시트 처리
        if (orderSheetName) {
            log(`[처리] '${orderSheetName}' 시트를 분석합니다...`);
            const ws = workbook.Sheets[orderSheetName];
            const result = buildRecordsFromSheet(ws, orderSheetName, year);
            
            // buildRecordsFromSheet 함수가 반환한 연도 값을 확정
            if (result.year) {
                year = result.year;
                log(`> 기준 연도를 '${year}'으로 설정했습니다.`, 'ok');
            }

            if (result.records.length > 0) {
                log(`> ${result.records.length}개의 발주 데이터를 발견했습니다.`);
                await deleteExistingData('orders', result.months, result.items, basePath);
                await uploadSheetData(result.records, basePath);
            } else {
                log(`> 처리할 발주 데이터가 없습니다.`, 'warn');
            }
        } else {
            log(`[정보] '발주월별' 시트를 찾을 수 없습니다.`, 'warn');
        }

        // 2. 입고 시트 처리
        if (receiptSheetName) {
            log(`[처리] '${receiptSheetName}' 시트를 분석합니다...`);
            
            // 만약 발주 시트가 없거나 연도를 못찾았다면, 현재 연도를 기준으로 사용
            if (!year) {
                year = new Date().getFullYear().toString();
                log(`> 기준 연도를 현재 연도인 '${year}'으로 설정합니다.`, 'warn');
            }

            const ws = workbook.Sheets[receiptSheetName];
            const result = buildRecordsFromSheet(ws, receiptSheetName, year);
            
            if (result.records.length > 0) {
                log(`> ${result.records.length}개의 입고 데이터를 발견했습니다.`);
                await deleteExistingData('receipts', result.months, result.items, basePath);
                await uploadSheetData(result.records, basePath);
            } else {
                log(`> 처리할 입고 데이터가 없습니다.`, 'warn');
            }
        } else {
            log(`[정보] '입고(날짜별)' 시트를 찾을 수 없습니다.`, 'warn');
        }

        log(`[완료] 모든 작업이 성공적으로 종료되었습니다.`, 'ok');

    } catch (e) {
        log(`[오류] 작업 중단: ${e && e.message ? e.message : e}`, 'err');
    } finally {
        $("#runBtn").disabled = false;
    }
});
</script>
</body>
</html>
